commit 35a897782b6b0a252da7fdcf4921198ad4e1d96c
Author: James Clarke <jrtc27@jrtc27.com>
Date:   Thu Nov 22 11:55:17 2018 -0500

    UNREG: PprC: Add support for adjacent floats
    
    When two 32-bit floats are adjacent for a 64-bit target, there is no
    padding between them to force alignment, so we must combine their bit
    representations into a single word.
    
    Reviewers: bgamari, simonmar
    
    Reviewed By: simonmar
    
    Subscribers: rwbarton, carter
    
    GHC Trac Issues: #15853
    
    Differential Revision: https://phabricator.haskell.org/D5306

Index: b/compiler/cmm/PprC.hs
===================================================================
--- a/compiler/cmm/PprC.hs
+++ b/compiler/cmm/PprC.hs
@@ -512,9 +512,12 @@ pprLit1 other = pprLit other
 pprStatics :: DynFlags -> [CmmStatic] -> [SDoc]
 pprStatics _ [] = []
 pprStatics dflags (CmmStaticLit (CmmFloat f W32) : rest)
-  -- floats are padded to a word by padLitToWord, see #1852
+  -- odd numbers of floats are padded to a word by mkVirtHeapOffsetsWithPadding
   | wORD_SIZE dflags == 8, CmmStaticLit (CmmInt 0 W32) : rest' <- rest
   = pprLit1 (floatToWord dflags f) : pprStatics dflags rest'
+  -- adjacent floats aren't padded but combined into a single word
+  | wORD_SIZE dflags == 8, CmmStaticLit (CmmFloat g W32) : rest' <- rest
+  = pprLit1 (floatPairToWord dflags f g) : pprStatics dflags rest'
   | wORD_SIZE dflags == 4
   = pprLit1 (floatToWord dflags f) : pprStatics dflags rest
   | otherwise
@@ -1261,6 +1264,25 @@ floatToWord dflags r
              , wORDS_BIGENDIAN dflags    = 32
              | otherwise                 = 0
 
+floatPairToWord :: DynFlags -> Rational -> Rational -> CmmLit
+floatPairToWord dflags r1 r2
+  = runST (do
+        arr <- newArray_ ((0::Int),1)
+        writeArray arr 0 (fromRational r1)
+        writeArray arr 1 (fromRational r2)
+        arr' <- castFloatToWord32Array arr
+        w32_1 <- readArray arr' 0
+        w32_2 <- readArray arr' 1
+        return (pprWord32Pair w32_1 w32_2)
+    )
+    where pprWord32Pair w32_1 w32_2
+              | wORDS_BIGENDIAN dflags =
+                  CmmInt ((shiftL i1 32) .|. i2) W64
+              | otherwise =
+                  CmmInt ((shiftL i2 32) .|. i1) W64
+              where i1 = toInteger w32_1
+                    i2 = toInteger w32_2
+
 doubleToWords :: DynFlags -> Rational -> [CmmLit]
 doubleToWords dflags r
   = runST (do
